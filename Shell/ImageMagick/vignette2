#!/bin/bash
#
# Developed by Fred Weinhaus 1/20/2012 .......... 1/20/2012
#
# USAGE: vignette2 [-a amount] [-d dim] [-s shape] [-r round] [-c color] [-m method] [-i] infile outfile
# USAGE: vignette2 [-help|-h]
#
# OPTIONS:
#
# -a     amount     vignette amount; blur sigma value; integer>0; default=25
# -d     dim        vignette region boundary; relative size compared to the
#                   input image expressed as width,height in percent or pixels;
#                   integer>0; if percent, add % symbol; default=90%
# -s     shape      shape of vignette region boundary; choices are: 
#                   rectangle, roundrectangle, ellipse or circle; 
#                   default=roundrectangle
# -r     round      amount of rounding for roundrectangle; integer>0; 
#                   default=2*amount
# -c     color      vignette color; any IM opaque color; default=black
# -m     method     vignette color compose method; any IM compose method; 
#                   default=multiply
# -i                invert the vignette effect from outside to inside
#  
#
###
#
# NAME: VIGNETTER2 
# 
# PURPOSE: Applies a vignette effect to a picture.
# 
# DESCRIPTION: VIGNETTER2 applies a vignette effect to a picture. The vignette 
# shape may be any of the following: rectangle, roundrectangle, ellipse or 
# circle. This is similar to the way Photoshop does vignetting.
# 
# 
# OPTIONS: 
# 
# -a amount ... AMOUNT is the vignette amount expressed as a blur sigma value. 
# Values are integer>0. The default=25.
# 
# -d dim ... DIM are vignette region boundary dimensions relative to the
# size of the input image expressed as Width,Height in percent or pixels. 
# One or two values may be supplied. If only one, then it will be used for 
# the second dimension if needed. Values are integers>0. If percent, then 
# add % symbol as Width%[,Height%]. Vignette dimensions must not be larger  
# than the image dimensions or 100%. The default=90%.
# 
# -s shape ... SHAPE is the shape of the vignette region boundary. The choices 
# are: rectangle (r), roundrectangle (rr), ellipse (e) or circle (c). 
# The default=roundrectangle.
# 
# -r round ... ROUND is the amount of rounding for roundrectangle. Values are
# integers>0. The default=2*amount.
# 
# -c color ... COLOR is the vignette color. Any IM color is allowed. 
# The default=black.
# 
# -m method ... METHOD is the vignette color compose method. Any IM compose 
# method is allowed. The default=multiply.
# 
# -i ... INVERT the vignette effect from outside to inside.
# 
# CAVEAT: No guarantee that this script will work on all platforms, 
# nor that trapping of inconsistent parameters is complete and 
# foolproof. Use At Your Own Risk. 
# 
######
#

# set up defaults
amount=25				# vignette amount; blur sigma
dim="90%"				# vignette transition region boundary; size compared to image % or pixels
shape="roundrectangle"	# rectangle, roundrectangle, ellipse, circle
round=""				# size of rounding for roundrectangle; default=2*amount
color="black"			# vignette color (not white)
method="multiply"		# vignette color compose method
invert="no"				# invert vignette to inside rather than outside dim

# set directory for temporary files
dir="."    # suggestions are dir="." or dir="/tmp"

# set up functions to report Usage and Usage with Description
PROGNAME=`type $0 | awk '{print $3}'`  # search for executable on path
PROGDIR=`dirname $PROGNAME`            # extract directory of program
PROGNAME=`basename $PROGNAME`          # base name of program
usage1() 
	{
	echo >&2 ""
	echo >&2 "$PROGNAME:" "$@"
	sed >&2 -n '/^###/q;  /^#/!q;  s/^#//;  s/^ //;  4,$p' "$PROGDIR/$PROGNAME"
	}
usage2() 
	{
	echo >&2 ""
	echo >&2 "$PROGNAME:" "$@"
	sed >&2 -n '/^######/q;  /^#/!q;  s/^#*//;  s/^ //;  4,$p' "$PROGDIR/$PROGNAME"
	}


# function to report error messages
errMsg()
	{
	echo ""
	echo $1
	echo ""
	usage1
	exit 1
	}


# function to test for minus at start of value of second part of option 1 or 2
checkMinus()
	{
	test=`echo "$1" | grep -c '^-.*$'`   # returns 1 if match; 0 otherwise
    [ $test -eq 1 ] && errMsg "$errorMsg"
	}

# test for correct number of arguments and get values
if [ $# -eq 0 ]
	then
	# help information
   echo ""
   usage2
   exit 0
elif [ $# -gt 15 ]
	then
	errMsg "--- TOO MANY ARGUMENTS WERE PROVIDED ---"
else
	while [ $# -gt 0 ]
		do
			# get parameter values
			case "$1" in
		     -help|-h)    # help information
					   echo ""
					   usage2
					   exit 0
					   ;;
				-a)    # get amount
					   shift  # to get the next parameter
					   # test if parameter starts with minus sign 
					   errorMsg="--- INVALID AMOUNT SPECIFICATION ---"
					   checkMinus "$1"
					   amount=`expr "$1" : '\([0-9]*\)'`
					   [ "$amount" = "" ] && errMsg "--- AMOUNT=$amount MUST BE AN INTEGER ---"
					   test1=`echo "$amount < 0" | bc`
					   [ $test1 -eq 1 ] && errMsg "--- AMOUNT=$amount MUST BE A NON-NEGATIVE INTEGER (with no sign) ---"
					   ;;
				-d)    # get dim
					   shift  # to get the next parameter
					   # test if parameter starts with minus sign 
					   errorMsg="--- INVALID DIM SPECIFICATION ---"
					   checkMinus "$1"
					   dim=`expr "$1" : '\([%0-9]*,*[%0-9]*\)'`
					   [ "$dim" = "" ] && errMsg "--- DIM=$dim MUST BE A COMMA SEPARATED PAIR OF NON-NEGATIVE INTEGERS (with no sign) ---"
					   ;;
				-s)    # shape
					   shift  # to get the next parameter
					   # test if parameter starts with minus sign 
					   errorMsg="--- INVALID SHAPE SPECIFICATION ---"
					   checkMinus "$1"
					   shape="$1"
					   shape=`echo "$shape" | tr "[:upper:]" "[:lower:]"`
					   case "$shape" in 
							rectangle|r) shape="rectangle";;
							roundrectangle|rr) shape="roundrectangle";;
							ellipse|e) shape="ellipse";;
							circle|c) shape="circle";;
							*) errMsg "--- SHAPE=$shape IS AN INVALID VALUE ---" 
						esac
					   ;;
				-r)    # get round
					   shift  # to get the next parameter
					   # test if parameter starts with minus sign 
					   errorMsg="--- INVALID ROUND SPECIFICATION ---"
					   checkMinus "$1"
					   round=`expr "$1" : '\([0-9]*\)'`
					   [ "$round" = "" ] && errMsg "--- ROUND=$round MUST BE AN INTEGER ---"
					   test1=`echo "$round < 0" | bc`
					   [ $test1 -eq 1 ] && errMsg "--- ROUND=$round MUST BE A NON-NEGATIVE INTEGER (with no sign) ---"
					   ;;
				-c)    # get color
					   shift  # to get the next parameter
					   # test if parameter starts with minus sign 
					   errorMsg="--- INVALID COLOR SPECIFICATION ---"
					   checkMinus "$1"
					   color="$1"
					   ;;
				-m)    # get method
					   shift  # to get the next parameter
					   # test if parameter starts with minus sign 
					   errorMsg="--- INVALID METHOD SPECIFICATION ---"
					   checkMinus "$1"
					   method="$1"
					   ;;
				-i)    # get invert
					   invert="yes"
					   ;;
			 	-)    # STDIN and end of arguments
					   break
					   ;;
				-*)    # any other - argument
					   errMsg "--- UNKNOWN OPTION ---"
					   ;;
		     	 *)    # end of arguments
					   break
					   ;;
			esac
			shift   # next option
	done
	#
	# get infile and outfile
	infile=$1
	outfile=$2
fi

# test that infile provided
[ "$infile" = "" ] && errMsg "NO INPUT FILE SPECIFIED"

# test that outfile provided
[ "$outfile" = "" ] && errMsg "NO OUTPUT FILE SPECIFIED"


# setup temp files
tmpA1="$dir/vignette2_1_$$.mpc"
tmpB1="$dir/vignette2_1_$$.cache"
trap "rm -f $tmpA1 $tmpB1; exit 0" 0
trap "rm -f $tmpA1 $tmpB1; exit 1" 1 2 3 15

# test input image
convert -quiet -regard-warnings "$infile" +repage "$tmpA1" ||
	errMsg "--- FILE $infile DOES NOT EXIST OR IS NOT AN ORDINARY FILE, NOT READABLE OR HAS ZERO SIZE ---"


# get image dimensions for later cropping as input is padded to square, even dimensions
ww=`identify -ping -format "%w" $dir/tmpI.mpc`
hh=`identify -ping -format "%h" $dir/tmpI.mpc`

cx=`convert xc: -format "%[fx:$ww/2]" info:`
cy=`convert xc: -format "%[fx:$hh/2]" info:`

test=`echo "$dim" | grep "%"`
if [ "$test" = "" ]; then
	units="pixels"
else
	units="percent"
fi
dim=`echo "$dim" | sed 's/%//g'`
dimx=`echo "$dim" | cut -d, -f1`
dimy=`echo "$dim" | cut -d, -f2`

if [ "$round" = "" ]; then
	rx=$((2*amount))
	ry=$((2*amount))
else
	rx=`echo "$round" | cut -d, -f1`
	ry=`echo "$round" | cut -d, -f2`
fi

if [ "$units" = "percent" ]; then
	ww2=`convert xc: -format "%[fx:$dimx*$cx/100]" info:`
	hh2=`convert xc: -format "%[fx:$dimy*$cy/100]" info:`
	# test if vignette dim <= image size
	[ $dimx -gt 100 ] && echo  "--- VIGNETTE WIDTH MUST NOT BE LARGER THAN IMAGE WIDTH ---"
	[ $dimy -gt 100 ] && echo  "--- VIGNETTE HEIGHT MUST NOT BE LARGER THAN IMAGE HEIGHT ---"
	
else
	ww2=$cx
	hh2=$cy
	# test if vignette dim <= image size
	[ $dimx -gt $ww ] && echo  "--- VIGNETTE WIDTH MUST NOT BE LARGER THAN IMAGE WIDTH ---"
	[ $dimy -gt $hh ] && echo  "--- VIGNETTE HEIGHT MUST NOT BE LARGER THAN IMAGE HEIGHT ---"
fi
echo "ww=$ww; hh=$hh; cx=$cx; cy=$cy; units=$units; dimx=$dimx; dimy=$dimy; rx=$rx; ry=$ry; ww2=$ww2; hh2=$hh2"

if [ "$shape" = "rectangle" ]; then
	args="-$ww2,-$hh2 $ww2,$hh2"
elif [ "$shape" = "roundrectangle" ]; then
	args="-$ww2,-$hh2 $ww2,$hh2 $rx,$ry"
elif [ "$shape" = "ellipse" ]; then
	args="0,0 $ww2,$hh2 0,360"
elif [ "$shape" = "circle" ]; then
	rad=`convert xc: -format "%[fx:min($ww2,$hh2)]" info:`
	args="0,0 $rad,0"
fi
echo "shape=$shape args=$args"
echo "translate $cx,$cy $shape $args"

if [ "$invert" = "yes" ]; then 
	inversion="-negate -virtual-pixel black"
else
	inversion="-virtual-pixel white"
fi

convert $tmpA1 \
	\( -clone 0 -fill "$color" -colorize 100%  \) \
	\( -clone 0 -fill white -colorize 100% -fill black \
		-draw "translate $cx,$cy $shape $args" $inversion -blur 0x$amount \) \
	-compose $method -composite $outfile


exit 0